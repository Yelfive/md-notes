# Some ideas about Laravel Admin extension

## Overall conventions

### table with plural, model with singular

e.g.

```text
table: users
model: User
```

### Use js to generate all doms, not with `Laravel blade`

Calling

```php
$form->text('name');
```

will get

```js
// Generated by PHP
const data = {name: {value: 'Felix', label: 'Name'}};
admin.text(data.name);
```

then rendered as html

```html
<label for="user-name">Name</label>
<input id="user-name" type="text" name="name" value="Felix"/>
```

`Laravel` will use the convention, the plural of model is the name of the table.

## Model

1. `$form/$grid` translation uses `Model::getAttributeLabels();` by default
2. `$form` rules use `Model::rules` by default

## Form

1. Use selector to locate HTML element, like jQuery

   ```php
   // Laravel Admin can only specify some fixed elements' properties:
   //
   // <div class="readonly">
   //     <input readonly="readonly" />
   //  </div>
   $form->file()->readonly();

   // Expect: allow to locate element by selector
   // <input readonly="readonly">
   $form->file()->findInput('selector')->readonly();
   ```

2. Validation should have `keyup/change` listeners

   To validate corresponding rules as specified by `$form->rules` or `Model::rules`. `Laravel Admin` does not have such mechanism, it validates only in the backend.

3. `Form` SHOULD have access to the value of current record, when it's editing.
  
   ```php
   $form->tools(function (Form\Tools $tools) {
      /** @var Form $this */
      // Not allowed to delete super user.
      if ($this->model()->id === 1) $tools->disableDelete();

      if ($this->isEditing()) (new Button())
            ->setIcon('fa-credit-card')
            // Needs $model->id to generate link
            ->setAction([BankCardController::class, 'index'], ['user' => $this->model()->id])
            ->appendTo($tools);
   });
   ```

   This can be achieved in `Laravel Admin` by the following code

   ```php
   $form = new Form(User::findOrFail($id));
   ```

   However, when `$form->edit($id)` is called, the same data will be queried a second time, which may cause significant database overheads.

4. `Laravel Admin` prepares form data after validation. For example,

   ```php
   // Controller
   $form->switch('is_boolean');
   ```

   Inside class `\Encore\Admin\Form`,

   1. `Form::store` -> `Form::validationMessages`-> `Form::prepareInsert`
   2. `Form::update` -> `Form::validationMessages` -> `Form::prepareUpdate`

      ```php
      // 1. validation
      $this->validationMessages();
      // 2. prepare
      $field->prepare($value);
      ```

   This makes rules of model generated by command `reference:model` cannot be applied by such `store,update` methods, because for some fields, `switch` for example, the client posts `on/off` as value to the server, which validates, then `prepares` the value into `1/0`, finally saves it into database.

   **Expectation**:

   `Field::prepare` **MUST** be called before `\Encore\Admin\Form::validationMessages` to keep consistent to `Laravel` and `reference:model`, if it is still needed.

5. `select2`, cannot pass JS functions to it

   `Laravel Admin` uses `json_encode` to encode `$config`, which makes it impossible to pass functions to `select2` etc..

   ```php
   public function render()
   {
      $configs = array_merge([
         'allowClear'  => true,
         'placeholder' => [
               'id'   => '',
               'text' => $this->label,
         ],
      ], $this->config);

      $configs = json_encode($configs);

      if (empty($this->script)) {
         $this->script = "$(\"{$this->getElementClassSelector()}\").select2($configs);";
      }
      // other code..
   }
   ```

   **EXPECTATION** Use custom encoder, such as `\fk\helpers\Dumper` to encode, it allows use of `\fk\helpers\DumperExpression` to keep the JS function as is.

6. `Form` will not load data until `Form::edit()` called

   `Laravel Admin` assumes that a `From` is either in **edit** mode or **create** mode, and load data only when `Form::edit` is called. Actually sometimes I needed the data before this was called.

   It's better to use state of `Eloquent Model` to decide the current mode, leaving more customization to developers.

   **EXPECTATION**

   ```php
   $form = new Form(User::findOrFail($id));
   return $form->render(); // HTML that contains user data.
   ```

7. element class should have default class

   ```php
   $form->text('field')
      // to add to default list
      // $this->elementClasses = array_merge($this->elementClasses, $classes)
      ->addElementClass($classes)
      // to remove from list, including default
      // $this->elementClasses = array_key_diff($this->elementClasses, array_flip($classes))
      ->removeElementClass($classes)
      // to overwrite
      // $this->defaultElementClasses = $classes;
      ->overwriteElementClass($classes);
   ```

   Or consider the following pattern

   ```php
   class Element implements Htmlable, Renderable {}
   class Elements implements Htmlable, Renderable {}
   ```

### Form layout

```php

$form->text('name');

// equivalent to
$form->row(function (Row $row) {
   $row->grid(12, function(Column $column) {
      $column->text('name');
   });
});

// This allows more flexible layout like
$form->row(function(Row $row) {
   $row->grid(6, function(Column $column) {
      $column->text('name');
   });
   // other grids...
});

```

### Form fields

#### 1. `number` should be able to set step

   ```php
   $form->number('column')->step(1000); // atom unit is 1000
   ```

#### 2. Form fields should have some idea of generating unique element ids, and maybe prefix

   ```php
   <?php
   $form->prefixIdWith('hello_');
   $form->text('name');
   // result
   // <input type="text" name="name" id="hello_name"/>
   ```

   > **NOTE: Also should consider when a field is rendered twice, the id should be unique.**

#### 3. Form fields should allow extending

```php
<?php

// Display this field only when with empty value
Field::extend('whenEmpty', function (mixed $value, Field $field) {
    if ($value) {
        $field->shouldDisplay = true;
    } else {
        $field->shouldDisplay = false;
    }
    return $this;
});

// Applies to all fields
$form->text('name')->whenEmpty();
$form->select('country')->whenEmpty();
```

#### 4. HasMany does not relation does not respect `HasAttributes::snakeAttributes`

```php
// Get relation by calling Model::rankHistory
$form->hasMany('rankHistory', function() {
    // but actually cannot get any fields
    // because laravel uses snake case of relation name as key
    // to store data when calling Model::toArray
    //
    // $rankHistory['rank_history'] = $model->rankHistory->toArray()
    //
    // and LaravelAdmin uses toArray to get fields' values from model
    // and retrieve them using camel case
    //
    // $data['rankHistory']['id']
    // instead of $data['rank_history']['id']
});

// see Illuminate\Database\Eloquent\Concerns\HasAttributes(260) for more
```

## Grid

### 1. Link on field

   ```php
   // generate a link to redirect to edit/view page on `name` field
   $grid->column('name')->linkToEditPage();
   ```

### 2. `Grid/Form` should query required fields, not the all of the table

e.g.

   ```php
   $grid->column('id');
   $grid->column('name');
   ```

   Should generate

   ```sql
   SELECT id, name FROM table_name;
   -- other than
   SELECT * FROM table_name;
   ```

### 3. `$grid->image` **SHOULD** be available to set `height`, not just `width`

### 4. `\Encore\Admin\Grid\Displayers\RowSelector` does not support `checked=true` attributes, which should be otherwise

### Filter input is not consistent with other fields

### 5. Filter input cannot

1. Have `help` message, consider this, compose a `Input` component to represent for all inputs, with all kinds of features but allows user to set the properties to either switch it on/off or others.

### Grid excellent feature

1. `$grid->column()->display`: callback passed until render, that way, we can go through the whole data set, and process them. Some processing might need all data of current page, such as injecting some `JS` to pop up a modal for all rows.

### Grid should have resizable width

1. when it's being resizing, and when actual size is wider, should display with ellipsis `xxx...`.

### Should have access to custom row style

```html
<tr class="message-read"></tr>
```

## 3. `Laravel-admin` uses pjax, which has bug with PHP

Consider this example

```php
<?php

$dom = new \DOMDocument('1.0', 'utf-8');
$dom->loadHTML(<<<HTML
<script>
   let a = <span>123</span>
</script>
HTML
);

echo $dom->saveHTML();
```

will result:

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><head><script>
let a = '<span>123';
</script></head></html>
```

with **closing tag removed**. In fact, everything after the closing tag is removed too.

`Laravel-Admin` uses `\Symfony\Component\DomCrawler\Crawler`, which uses `\DOMDocument`, which uses `libxml` to get `pjax` container's content. And this is a known bug with `libxml`, which does not support `HTML5`.

With this bug under consideration, the pjax response passing should take place at browser side, instead of server side.

### 4. Allows `$form->text()->ignore()`

Currently supported syntax:

```php
$form->text('should-be-ignored');
$form->ignore('should-be-ignored');
```

Expected:

```php
$form->text('should-be-ignored')->ignore();
```

to ignore specific field.

## Binding `Form` as `$this`

*Laravel Admin* binds class `Form` to callbacks as `$this`, and such behavior makes calling methods from controller inside callbacks troublesome.

**DO NOT bind anything, just variables passing.**

```php
// source code
$this->$callback($value, $form);

// usage
$column->display(function ($value, Form $form) {
   $this->methodInController();
});
```

## Command `reference:model`

1. SHOULD be able to use `TableNameContract` and `TableName` model strategy and create those two files simultaneously.

2. Consistent with `Laravel`'s convention, **singular for table, plural for `Model`**:

   > Note that we did not tell `Eloquent` which table to use for our `Flight` model. By convention, the "snake case", plural name of the class will be used as the table name unless another name is explicitly specified. So, in this case, Eloquent will assume the `Flight` model stores records in the `flights` table. You may specify a custom `table` by defining a table property on your model.

3. Default to generate contract

4. Allow rule overwriting

   ```php
      public function rules()
      {
         // No static variable to store the rule
         // static variable has one problem: when the rule is based on state(object properties etc.),
         // it will not change when state changes.
         $rules = [
            // rules generated from database
         ];

         $rules = array_merge($rules, $this->replaceRules());

         return $rules;
      }

      protected function replaceRules()
      {
         return [
            'name' => ['rules'],
            'mobile' => ['rules'],
         ];
      }
   ```

5. Allow to use trait instead of only extends

   ```php
   <?php

   namespace App\Models;

   class User extends OtherBaseModel
   {
      use UserContract;
   }
   ```

   For example, `laravel/passport` uses a `Laravel\Passport\Client` as the base `Model`, thus cannot extends another model.

6. Rewrite migrate to auto `reference:model`

   ```php
   <?php

   class SomeMigrate extends Migration
   {
      public function up()
      {
         // run reference:model after up
      }

     public function down()
     {
       // run reference:model after down
     }
   }
   ```

## Command `trans:extract`

1. **SHOULD** be able to extract one file.
2. **SHOULD** compare change of file before extracting, e.g. extract `UserController` only when changed.

## Command `model:label`

1. Generate locale method `getAttributeLabels` for a model, SHOULD be considered being **ABLE** to be included inside `reference:model`
2. Generate `key=>value` pairs: `'key' => __('table-name.attributes.key')`, with `attributes` prefix the value
3. SHOULD allow to customize map for model fields, fx.  `created_at` will be `__('Created at')` instead of `__(table-name.Created at)`

## Command `map:const`

Generate labels for model constants, SHOULD be considered being **ABLE** to be included inside `reference:model`

## Methods that should accept returns of any type

- `$grid->column()->modal()` in `\Encore\Admin\Grid\Displayers\Modal`

## Image previewer

Preview image in any page.

for example

```html
<img src="grep.jpeg"/>

<script>
$('img').preview();
</script>

```

## Server overload problem

`Laravel Admin` parsing everything at server side, which significant increase the server's load.

**SHOULD** consider frontend-backend isolation solution. Leave the `HTML` to client and data to the server. `PHP` is not very good at dealing with that.

## Tree

- Tree actions: cannot custom actions, say, add a create child button, change the icon etc.

   see `src/vendor/encore/laravel-admin/resources/views/tree/branch.blade.php`

## `Support` class

### `Support\Str`

```php
Str::camel($string, $delimiter = '_'); // 'one_two' => oneTwo
```
