---
css: z_custom.css
---

# Algorithm

## AVL Tree

平衡二叉树

## 红黑树的性质

红黑树是二叉排序树，深度不超过 `n / 2`

1. 每个结点不是红色就是黑色
2. 根结点为黑色
3. 叶结点为黑色（`=nil`）
4. 红色结点的子结点为黑色
5. 任何结点到其子树的叶结点包含的黑色节点数相同，称黑高。（树的黑高为根节点的黑高）

新增、修改一个结点，可能破坏以上性质，通过

1. 旋转：左旋、右旋
2. 变色

使其再次满足以上 5 点性质。

## 排序算法有哪些，什么特点

堆排序、最大堆、大根堆、大顶堆

树，怎么了

## 霍夫曼编码 Huffman 的原理，解决什么问题

利用最优二叉树对字符串编码，减少字符串长度。也可以做无损压缩

将出现次数最少（权重为出现的次数）的字符放在树的最底层。

\\[
\sum_{i=1}^n{w_il_i}
\\]

\\(w_i\\) 为出现的次数，\\(l_i\\) 为深度。则上式为报文长度。

Huffman 编码使该 *带权路径长度* 最短。

对于序列\\(a_1, a_2, ...,a_n\\)

1. 先取最小两个值相加的\\(b_i\\)形成新队列\\(\{b_1,a_3,...,a_n\}\\)
2. 对新队列重复上述步骤直至只有一个元素

---

对于字符串 `ACABBDA`，其中字符出现的次数为

| Char | Count | Bit  |
| ---- | ----- | ---- |
| A    | 3     | 0    |
| B    | 2     | 10   |
| C    | 1     | 110  |
| D    | 1     | 111  |

使用 `count` 作为权值，可以得到下面的 Huffman 树。此时的压缩后结果为 (占13位)

```
0 1100 1010 1110
```



![image-20210614142220409](image-20210614142220409.png)

## 求是整数二进制表示是否只有一个 1

`n & (n - 1) == 0`

## 数据结构有哪些

1. 队列
2. 栈
3. 链表：单向、双向、循环
4. 树：二叉树、平衡树、红黑树
5. 图

## 不使用加做加法（整数）

使用位运算，同位置均为 1 则需要进位（按位与后左移 1 位），否则不需要进位（异或）

使用 `b` 存储进位，则当进位为 0 时，表示计算结束。

```java
// a + b
while (b != 0) {
  int c = a & b << 1;	// 进位
  a ^= b; 						// 不进位
  b = c;
}
return a;
```

## 不使用乘做乘法（整数）

考虑 `res = a * b`，相当于 `a` 的 `b` 倍，则可以使用加法，来叠加 `a`。为了降低时间复杂度，

1. 当 `b` 为偶数时，则可化为 `res = (a * b / 2) * 2`，二分 `b`
2. 当 `b` 为奇数时，则可化为 `res = (a * (b - 1) /2) * 2 + a`

```java
// a * b
int res = 0;
while (b != 0) {
  if ((b & 1) == 1) res += a;
  a <<= 1;
  b >>>= 1;
}
return res;
```

> 注意 `b >>>= 1` 是按无符号右移 1 位。这样便可以对负数同样有效

