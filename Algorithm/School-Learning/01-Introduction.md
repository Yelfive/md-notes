# Introduction

## 术语（Terminology）

### 复杂度的度量（Complicity measurement）

复杂度用于判断算法使用的时间、空间的使用情况；当问题的规模足够大时，时间、空间使用的增长情况，描述算法的好坏。

- $O$：复杂度上限
- $\Omega$：复杂度下限

## 算法

### 1. Recursion (递归)

方法体内部调用自身的编程技巧。

```c
void recursion() {
    // ...
    recursion();
    // ...
}
```

1. [整数划分](./Recursion/Integer-Partition.md)
2. 汉诺塔 hanoi
3. 阶乘 $n!$

### 2. Divide and Conquer (分治)

分治将解决问题分为三个步骤：

- Divide: 将一个大问题分解为较小的独立子问题。
- Conquer： 独立的解决子问题。
- Merge: 将子问题的解合并成原问题的解。

> 大问题应该分解为大小（几乎）相等的子问题。

通常使用[递归](#1-recursion-递归)来实现分治算法.

**常见使用分治解决的问题:**

1. 二分查找（Binary search
2. 大数乘法：减少乘法次数

    $$
    XY = ac\cdot2^n + (ad+bc)\cdot2^{n/2} + bd     \tag{1}
    $$

    转化为

    $$
    XY = ac\cdot2^n + [(a-b)(d-c)+ac+bd] \cdot 2^{n/2} + bd         \tag{2}
    $$

    以减少乘法次数, 式$(1)$需要计算`4`次乘法，式$(2)$只需要计算`3`次乘法。

3. 矩阵乘法

    利用矩阵分块减少乘法次数

4. 棋盘覆盖问题

    用 `L` 型骨牌覆盖棋盘中, 除特殊方格以外的所有方格

5. 快速排序(Quick Sort)
6. 线性时间选择

    在线性时间内找出第 `k` 小的数

7. 循环赛日程表问题
8. 最接近点对问题

    空间中距离最近的两点。一维情况下：数轴上距离最近的两点。

9. 最大子段和问题(Maximum Sub-Sequence Sum)

### 3. Dynamic Programming (DP, 动态规划)

如果问题可以分解成规模较小的子问题，但是子问题之间相不是相互独立的，
此时用[分治](#2-divide-and-conquer-分治)的方法将会增加许多重复的计算量（如 Fibonacci）。
为了解决这个问题，可以引入一张表来记录子问题的解，然后自底向上求解。

> DP 寻找的是最优解。

#### 核心概念

- **最优子结构**: 原问题的最优解包含了其导出子问题的最优解
- **自底向上**: 问题求解过程自底向上
- **最优值表**: 保存已解决的子问题答案
- **最优解表**: 记录最优值的求解过程
- **求解过程**: 利用已有**最优值表**，自底向上求解

> 问题具有 **最优子结构** 是使用DP求解的前提

#### DP典型问题

| 问题 | 时间复杂度 | 空间复杂度 | 描述
| ---- | ---------- | ---------- |---
|矩阵连乘问题                             |$O(n^3)$|$O(n^2)$|利用结合律，减少数乘次数
|[最长公共子序列问题(Longest Common Subsequence, LCS)](DP/Maximum-Sub-Sequence-Sum.md)    |$O(mn)$|$O(mn)$|不连续子串
|最大子段和问题(Maximum Sub-Sequence Sum) |$O(n)$|$O(1)$|整数序列，求子序列，其和最大
|凸多边形最优三角剖分问题                |$O(n^3)$|$O(n^2)$|类似矩阵*矩阵连乘问题*
|图像压缩问题（Image Compression Problem）      |$O(n)$|$O(n)$|**最优分段** 使得占用空间最少
|[0-1背包问题](DP/0-1-Knapsack-Problem.md)|$O(n)$|$O(n)$|将物品放入容量 $C$ 的背包，求**最大价值** $max(\sum_{i=1}^{n}{v_ix_i})$
|[最优二叉查找树(Optimal Binary Search Tree)](DP/Optimal-Binary-Search-Tree.md)|$O(n^3)$|$O(n^2)$|根据给定递增、有序序列，构造最优二叉查找树，构造最优解的时间复杂度为 $O(n)$
|硬币找零|||假设有4种硬币，面值分别为：二角五分、一角、五分和一分。现在要找给顾客六角三分钱，如何找使得给出的硬币个数最少

> 与分治的区别在于，
>
> **分治**是将大的问题划为小的子问题，再递归的解决子问题，合并成大问题的解，
> 解决过程中同样的子问题可能被计算多次；
>
> 而**DP**使用表来记录子问题的求解，不重复计算子问题，空间换时间。

#### DP其他变形

- **备忘录方法**： 使用**自顶向下**的求解过程

### 4. Greedy Algorithm (贪心)

贪心算法本质是动态规划，但是贪心算法只考虑上一步的最优解，速度更快，从而导致最终找到的可能是局部最优解，而非全局最优解。

> 当可以证明贪心算法找到的局部最优解，可以最终得到全局最优解时，贪心算法与动态规划算法等价。

#### 贪心算法的基本要素

1. 贪心选择性质

    可以证明通过问题的局部最优解可以得到全局最优解。

2. 具有最优子结构

    与动态规划相同，具有最优子结构，才能通过贪心算法求得最优解

#### 常见问题

问题|时间复杂度|空间复杂度|描述
-- |--|--|--
活动安排问题    |已排序：$O(n)$<br>未排序：$O(n \log n)$| $O(n)$ |通过结束时间非递减排序进行安排，具有最优子结构。先结束时间排序。
背包问题        |$O(n \log n)$|$O(1)$| 物品可以分割，在背包容量 $C$ 条件下，求最大价值。先价值质量比排序。
最优装载问题    |$O(n \log n)$|$O(n)$| 忽略体积，在装载容量 $C$ 限制下，求装载集装箱数目最多。先价值小$\rightarrow$大排序。
单源最短路径(Dijkstra)|$O(n^2)$|$O(n)$| 有向图中，某顶点到其他顶点的最短距离。
多机调度(MultiProcessor Scheduling)|$O(n \log n)$| $O(1)$ | 多处理机，多个作业，求最小耗时。属于 NPC 问题，所有问题都可以约化到它。**贪心算法为近似算法**，最长处理时间作业优先。先排序。

### 5. Backtracking Algorithm (回溯 sù)

**核心概念**：子集树、排列树

深度优先

搜索求解：穷举、深度优先（回溯）、广度优先

问题|时间复杂度|空间复杂度|解空间|描述
-- | -- | -- | -- | --
0/1背包问题|||子集树|
旅行商问题（TSP）|$O(n \cdot 2^n)$||排列数|
最优装载问题|$O(2^n)$||子集树| $n$ 个集装箱，装上 2 艘载重分别为 $c_1$、$c_2$ 的轮船，求全部装载的方案。
批处理作业调度|$O(n!)$||排列树|$x = (x_1, x_2, ..., x_n)$， $x_i$ 表示第 $i$ 个作业的执行顺序。
连续邮资问题||||
圆排列问题||||
N-皇后问题|$O(n!)$|$O(n)$|排列树|
最大团问题||||
图的 $m$ 着色问题|$O(n \cdot m^n)$|||

最优装载问题时，等价于将 $c_1$ 尽量装满，其余的装载在 $c_2$，从而转化为 0-1 背包问题。
其中的“价值”为此处集装箱的“重量”

### 6. Branch and Bound Method (分支限界法)

类似[回溯法](#5-backtracking-algorithm-回溯-sù)，在解空间中搜索，他们主要区别在于，

|| 回溯法 | 分支限界法 |
| -- | -- | -- |
|**求解目标**|搜索全部解|搜索最优解/任意解|
|**搜索方式**|深度优先（DFS）|广度优先（Breadth First Search BFS） 或 *最小耗费优先*|
|**存储空间**|较小，跟深度有关|大很多，需要存储所有子节点及其孙节点|
|**算法速度**|较慢|较快|

#### 关键概念

1. **最大堆**：父节点的值比每个子孙节点的值都大
2. **最小堆**：父节点的值比每个子孙节点的值都小
3. **约束函数**：问题需要满足的隐式、显式约束。如背包问题中的背包容量。
4. **限界函数**：算法中动态计算出解的上界、下界，根据界限，减去界限外的*分支*。比如求最小值，若已经找到值为 `10` 的叶子节点，则可以剪去最小值大于等于 `10` 的分支。

#### 分支限界法典型例子

问题|时间复杂度|空间复杂度|解空间|描述
-- | -- | -- | -- | --
单源最短路径问题||||
装载问题||||
布线问题||||
0/1背包问题||||
最大团问题||||
旅行商问题||||
电路板排列问题||||
批处理作业调度问题||||

### 7. Randomized Algorithm (随机化算法)

在问题的求解过程中，通过**随机地**选择下一次计算的步骤的算法

::: tip 随机算法 vs. 概率算法

- 随机算法，Randomized Algorithm，获取解的途径是随机的
- 概率算法，Probabilistic Algorithm，取得的解具有随机性

:::
